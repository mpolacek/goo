# Binutils
## `as`
` ./as-new -o m.o m.s --64`

-  open `m.o` in `output_file_create`
   -  calls `bfd_openw` to open a file using the format `TARGET_FORMAT` and returns a `bfd`
   - `bfd_set_format` sets format to `bfd_object`

-  assemble `m.s` in `perform_an_assembly_pass`:
   1) `read_a_source_file` opens `m.s` using `input_file_open`; read the first char with `getc`, if it's not `#` then `ungetc` it.  Then keep reading: read stuff like `.file`, `.globl`, `.type`.
   2) when we read something like `pushq %rbp`, call `assemble_one` -> `md_assemble` which is the machine-dependent assembler, on x86_64 this function is defined in `gas/config/tc-i386.c`.  `md_assemble` will
       - `parse_insn`
       - `parse_operands`
       - save stuff into `struct _i386_insn`
       - find a template that matches the given insns: `match_template`
      - check if the prefix is valid
      - actually output the insn: `output_insn`
- after `match_template` we can see the opcode:
```
(gdb) p/x i.tm.base_opcode 
$21 = 0x50
(gdb) p i.tm.name
$23 = 0x50de5e "push"
```
the basic opcode should match the one [here](http://ref.x86asm.net/coder.html#x50); depending on its operand a certain value is added to it.  Another example:
```
(gdb) f
#0  md_assemble (line=<optimized out>, line@entry=0x5c2eaa "movq %rsp,%rbp") at /home/mpolacek/src/binutils-gdb/gas/config/tc-i386.c:4770
4770	  if (sse_check != check_none
(gdb) p/x i.tm.base_opcode 
$3 = 0x89
```
(see [mov](http://ref.x86asm.net/coder.html#x89)) 

- `md_begin` initializes the `op_hash` hash table
- `opcodes/i386-tbl.h` is the optable generated by `i386-gen`, contains the basic opcodes etc.
- `opcodes/i386-opc.tbl` is the table, it's where new instructions get added